/* math-window.c generated by valac 0.40.6, the Vala compiler
 * generated from math-window.vala, do not modify */

/*
 * Copyright (C) 1987-2008 Sun Microsystems, Inc. All Rights Reserved.
 * Copyright (C) 2008-2012 Robert Ancell.
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version. See http://www.gnu.org/copyleft/gpl.html the full text of the
 * license.
 */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include "libcalculator.h"
#include <gdk/gdk.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>
#include <gtksourceview/gtksource.h>


#define TYPE_MATH_WINDOW (math_window_get_type ())
#define MATH_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MATH_WINDOW, MathWindow))
#define MATH_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MATH_WINDOW, MathWindowClass))
#define IS_MATH_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MATH_WINDOW))
#define IS_MATH_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MATH_WINDOW))
#define MATH_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MATH_WINDOW, MathWindowClass))

typedef struct _MathWindow MathWindow;
typedef struct _MathWindowClass MathWindowClass;
typedef struct _MathWindowPrivate MathWindowPrivate;

#define TYPE_MATH_DISPLAY (math_display_get_type ())
#define MATH_DISPLAY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MATH_DISPLAY, MathDisplay))
#define MATH_DISPLAY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MATH_DISPLAY, MathDisplayClass))
#define IS_MATH_DISPLAY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MATH_DISPLAY))
#define IS_MATH_DISPLAY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MATH_DISPLAY))
#define MATH_DISPLAY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MATH_DISPLAY, MathDisplayClass))

typedef struct _MathDisplay MathDisplay;
typedef struct _MathDisplayClass MathDisplayClass;

#define TYPE_MATH_BUTTONS (math_buttons_get_type ())
#define MATH_BUTTONS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MATH_BUTTONS, MathButtons))
#define MATH_BUTTONS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MATH_BUTTONS, MathButtonsClass))
#define IS_MATH_BUTTONS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MATH_BUTTONS))
#define IS_MATH_BUTTONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MATH_BUTTONS))
#define MATH_BUTTONS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MATH_BUTTONS, MathButtonsClass))

typedef struct _MathButtons MathButtons;
typedef struct _MathButtonsClass MathButtonsClass;

#define TYPE_MATH_CONVERTER (math_converter_get_type ())
#define MATH_CONVERTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MATH_CONVERTER, MathConverter))
#define MATH_CONVERTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MATH_CONVERTER, MathConverterClass))
#define IS_MATH_CONVERTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MATH_CONVERTER))
#define IS_MATH_CONVERTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MATH_CONVERTER))
#define MATH_CONVERTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MATH_CONVERTER, MathConverterClass))

typedef struct _MathConverter MathConverter;
typedef struct _MathConverterClass MathConverterClass;
enum  {
	MATH_WINDOW_0_PROPERTY,
	MATH_WINDOW_EQUATION_PROPERTY,
	MATH_WINDOW_DISPLAY_PROPERTY,
	MATH_WINDOW_BUTTONS_PROPERTY,
	MATH_WINDOW_NUM_PROPERTIES
};
static GParamSpec* math_window_properties[MATH_WINDOW_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_BUTTON_MODE (button_mode_get_type ())
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _MathWindow {
	GtkApplicationWindow parent_instance;
	MathWindowPrivate * priv;
};

struct _MathWindowClass {
	GtkApplicationWindowClass parent_class;
};

struct _MathWindowPrivate {
	MathEquation* _equation;
	MathDisplay* _display;
	MathButtons* _buttons;
	gboolean right_aligned;
	gboolean remove_buttons;
	GtkMenuButton* menu_button;
	GtkLabel* mode_label;
	GtkGrid* grid;
	MathConverter* converter;
};

typedef enum  {
	BUTTON_MODE_BASIC,
	BUTTON_MODE_ADVANCED,
	BUTTON_MODE_FINANCIAL,
	BUTTON_MODE_PROGRAMMING,
	BUTTON_MODE_KEYBOARD
} ButtonMode;


static gpointer math_window_parent_class = NULL;

GType math_window_get_type (void) G_GNUC_CONST;
GType math_display_get_type (void) G_GNUC_CONST;
GType math_buttons_get_type (void) G_GNUC_CONST;
GType math_converter_get_type (void) G_GNUC_CONST;
#define MATH_WINDOW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_MATH_WINDOW, MathWindowPrivate))
static void math_window_copy_cb (MathWindow* self);
static void _math_window_copy_cb_gsimple_action_activate_callback (GSimpleAction* action,
                                                            GVariant* parameter,
                                                            gpointer self);
static void math_window_paste_cb (MathWindow* self);
static void _math_window_paste_cb_gsimple_action_activate_callback (GSimpleAction* action,
                                                             GVariant* parameter,
                                                             gpointer self);
static void math_window_undo_cb (MathWindow* self);
static void _math_window_undo_cb_gsimple_action_activate_callback (GSimpleAction* action,
                                                            GVariant* parameter,
                                                            gpointer self);
static void math_window_redo_cb (MathWindow* self);
static void _math_window_redo_cb_gsimple_action_activate_callback (GSimpleAction* action,
                                                            GVariant* parameter,
                                                            gpointer self);
static void math_window_mode_cb (MathWindow* self,
                          GSimpleAction* action,
                          GVariant* parameter);
static void _math_window_mode_cb_gsimple_action_activate_callback (GSimpleAction* action,
                                                            GVariant* parameter,
                                                            gpointer self);
static void math_window_clear_cb (MathWindow* self);
static void _math_window_clear_cb_gsimple_action_activate_callback (GSimpleAction* action,
                                                             GVariant* parameter,
                                                             gpointer self);
static void _gtk_window_close_gsimple_action_activate_callback (GSimpleAction* action,
                                                         GVariant* parameter,
                                                         gpointer self);
MathWindow* math_window_new (GtkApplication* app,
                             MathEquation* equation);
MathWindow* math_window_construct (GType object_type,
                                   GtkApplication* app,
                                   MathEquation* equation);
void math_converter_set_equation (MathConverter* self,
                                  MathEquation* equation);
void math_converter_set_category (MathConverter* self,
                                  const gchar* category);
void math_converter_set_conversion (MathConverter* self,
                                    const gchar* unit_a,
                                    const gchar* unit_b);
MathDisplay* math_display_new (MathEquation* equation);
MathDisplay* math_display_construct (GType object_type,
                                     MathEquation* equation);
void math_display_grabfocus (MathDisplay* self);
MathButtons* math_buttons_new (MathEquation* equation);
MathButtons* math_buttons_construct (GType object_type,
                                     MathEquation* equation);
GType button_mode_get_type (void) G_GNUC_CONST;
ButtonMode math_buttons_get_mode (MathButtons* self);
static void math_window_mode_changed_cb (MathWindow* self);
static void _math_window_mode_changed_cb_g_object_notify (GObject* _sender,
                                                   GParamSpec* pspec,
                                                   gpointer self);
void math_display_clear_history (MathDisplay* self);
MathButtons* math_window_get_buttons (MathWindow* self);
void math_window_critical_error (MathWindow* self,
                                 const gchar* title,
                                 const gchar* contents);
static gboolean math_window_real_key_press_event (GtkWidget* base,
                                           GdkEventKey* event);
MathEquation* math_window_get_equation (MathWindow* self);
static void math_window_scroll_changed_cb (MathWindow* self,
                                    GtkAdjustment* adjustment);
static void _math_window_scroll_changed_cb_gtk_adjustment_changed (GtkAdjustment* _sender,
                                                            gpointer self);
static void math_window_scroll_value_changed_cb (MathWindow* self,
                                          GtkAdjustment* adjustment);
static void _math_window_scroll_value_changed_cb_gtk_adjustment_value_changed (GtkAdjustment* _sender,
                                                                        gpointer self);
MathDisplay* math_window_get_display (MathWindow* self);
void math_display_grab_focus (MathDisplay* self);
void math_buttons_set_mode (MathButtons* self,
                            ButtonMode value);
static void math_window_finalize (GObject * obj);
static void _vala_math_window_get_property (GObject * object,
                                     guint property_id,
                                     GValue * value,
                                     GParamSpec * pspec);

static const GActionEntry MATH_WINDOW_window_entries[7] = {{"copy", _math_window_copy_cb_gsimple_action_activate_callback, NULL, NULL, NULL}, {"paste", _math_window_paste_cb_gsimple_action_activate_callback, NULL, NULL, NULL}, {"undo", _math_window_undo_cb_gsimple_action_activate_callback, NULL, NULL, NULL}, {"redo", _math_window_redo_cb_gsimple_action_activate_callback, NULL, NULL, NULL}, {"mode", _math_window_mode_cb_gsimple_action_activate_callback, "s", "\"basic\"", NULL}, {"clear", _math_window_clear_cb_gsimple_action_activate_callback, NULL, NULL, NULL}, {"close", _gtk_window_close_gsimple_action_activate_callback, NULL, NULL, NULL}};

static void
_math_window_copy_cb_gsimple_action_activate_callback (GSimpleAction* action,
                                                       GVariant* parameter,
                                                       gpointer self)
{
	math_window_copy_cb ((MathWindow*) self);
}


static void
_math_window_paste_cb_gsimple_action_activate_callback (GSimpleAction* action,
                                                        GVariant* parameter,
                                                        gpointer self)
{
	math_window_paste_cb ((MathWindow*) self);
}


static void
_math_window_undo_cb_gsimple_action_activate_callback (GSimpleAction* action,
                                                       GVariant* parameter,
                                                       gpointer self)
{
	math_window_undo_cb ((MathWindow*) self);
}


static void
_math_window_redo_cb_gsimple_action_activate_callback (GSimpleAction* action,
                                                       GVariant* parameter,
                                                       gpointer self)
{
	math_window_redo_cb ((MathWindow*) self);
}


static void
_math_window_mode_cb_gsimple_action_activate_callback (GSimpleAction* action,
                                                       GVariant* parameter,
                                                       gpointer self)
{
	math_window_mode_cb ((MathWindow*) self, action, parameter);
}


static void
_math_window_clear_cb_gsimple_action_activate_callback (GSimpleAction* action,
                                                        GVariant* parameter,
                                                        gpointer self)
{
	math_window_clear_cb ((MathWindow*) self);
}


static void
_gtk_window_close_gsimple_action_activate_callback (GSimpleAction* action,
                                                    GVariant* parameter,
                                                    gpointer self)
{
	gtk_window_close ((GtkWindow*) self);
}


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


static void
_math_window_mode_changed_cb_g_object_notify (GObject* _sender,
                                              GParamSpec* pspec,
                                              gpointer self)
{
	math_window_mode_changed_cb ((MathWindow*) self);
}


MathWindow*
math_window_construct (GType object_type,
                       GtkApplication* app,
                       MathEquation* equation)
{
	MathWindow * self = NULL;
	MathEquation* _tmp0_;
	MathConverter* _tmp1_;
	MathEquation* _tmp2_;
	MathConverter* _tmp3_;
	MathConverter* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_;
	MathDisplay* _tmp11_;
	GtkGrid* _tmp12_;
	MathDisplay* _tmp13_;
	MathDisplay* _tmp14_;
	MathDisplay* _tmp15_;
	MathButtons* _tmp16_;
	GtkGrid* _tmp17_;
	MathButtons* _tmp18_;
	gboolean _tmp19_ = FALSE;
	MathButtons* _tmp20_;
	ButtonMode _tmp21_;
	ButtonMode _tmp22_;
	MathButtons* _tmp23_;
	GtkCssProvider* provider = NULL;
	GtkCssProvider* _tmp24_;
	GdkScreen* _tmp25_;
	g_return_val_if_fail (app != NULL, NULL);
	g_return_val_if_fail (equation != NULL, NULL);
	self = (MathWindow*) g_object_new (object_type, "application", app, NULL);
	_tmp0_ = _g_object_ref0 (equation);
	_g_object_unref0 (self->priv->_equation);
	self->priv->_equation = _tmp0_;
	self->priv->right_aligned = TRUE;
	g_action_map_add_action_entries ((GActionMap*) self, MATH_WINDOW_window_entries, G_N_ELEMENTS (MATH_WINDOW_window_entries), self);
	_tmp1_ = self->priv->converter;
	_tmp2_ = self->priv->_equation;
	math_converter_set_equation (_tmp1_, _tmp2_);
	_tmp3_ = self->priv->converter;
	math_converter_set_category (_tmp3_, NULL);
	_tmp4_ = self->priv->converter;
	_tmp5_ = math_equation_get_source_units (equation);
	_tmp6_ = _tmp5_;
	_tmp7_ = _tmp6_;
	_tmp8_ = math_equation_get_target_units (equation);
	_tmp9_ = _tmp8_;
	_tmp10_ = _tmp9_;
	math_converter_set_conversion (_tmp4_, _tmp7_, _tmp10_);
	_g_free0 (_tmp10_);
	_g_free0 (_tmp7_);
	_tmp11_ = math_display_new (equation);
	g_object_ref_sink (_tmp11_);
	_g_object_unref0 (self->priv->_display);
	self->priv->_display = _tmp11_;
	_tmp12_ = self->priv->grid;
	_tmp13_ = self->priv->_display;
	gtk_grid_attach (_tmp12_, (GtkWidget*) _tmp13_, 0, 1, 1, 1);
	_tmp14_ = self->priv->_display;
	gtk_widget_show ((GtkWidget*) _tmp14_);
	_tmp15_ = self->priv->_display;
	math_display_grabfocus (_tmp15_);
	_tmp16_ = math_buttons_new (equation);
	g_object_ref_sink (_tmp16_);
	_g_object_unref0 (self->priv->_buttons);
	self->priv->_buttons = _tmp16_;
	_tmp17_ = self->priv->grid;
	_tmp18_ = self->priv->_buttons;
	gtk_container_add ((GtkContainer*) _tmp17_, (GtkWidget*) _tmp18_);
	_tmp20_ = self->priv->_buttons;
	_tmp21_ = math_buttons_get_mode (_tmp20_);
	_tmp22_ = _tmp21_;
	if (_tmp22_ != BUTTON_MODE_KEYBOARD) {
		_tmp19_ = TRUE;
	} else {
		_tmp19_ = FALSE;
	}
	self->priv->remove_buttons = _tmp19_;
	_tmp23_ = self->priv->_buttons;
	g_signal_connect_object ((GObject*) _tmp23_, "notify::mode", (GCallback) _math_window_mode_changed_cb_g_object_notify, self, 0);
	math_window_mode_changed_cb (self);
	_tmp24_ = gtk_css_provider_new ();
	provider = _tmp24_;
	gtk_css_provider_load_from_resource (provider, "/org/gnome/calculator/calculator.css");
	_tmp25_ = gtk_window_get_screen ((GtkWindow*) self);
	gtk_style_context_add_provider_for_screen (_tmp25_, (GtkStyleProvider*) provider, (guint) GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
	_g_object_unref0 (provider);
	return self;
}


MathWindow*
math_window_new (GtkApplication* app,
                 MathEquation* equation)
{
	return math_window_construct (TYPE_MATH_WINDOW, app, equation);
}


static void
math_window_clear_cb (MathWindow* self)
{
	MathDisplay* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_display;
	math_display_clear_history (_tmp0_);
}


static void
math_window_mode_changed_cb (MathWindow* self)
{
	GSimpleAction* action = NULL;
	GAction* _tmp0_;
	GSimpleAction* _tmp1_;
	MathButtons* _tmp2_;
	MathButtons* _tmp3_;
	ButtonMode _tmp4_;
	ButtonMode _tmp5_;
	gboolean _tmp26_ = FALSE;
	gboolean _tmp27_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_action_map_lookup_action ((GActionMap*) self, "mode");
	_tmp1_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp0_, g_simple_action_get_type (), GSimpleAction));
	action = _tmp1_;
	_tmp2_ = math_window_get_buttons (self);
	_tmp3_ = _tmp2_;
	_tmp4_ = math_buttons_get_mode (_tmp3_);
	_tmp5_ = _tmp4_;
	switch (_tmp5_) {
		default:
		case BUTTON_MODE_BASIC:
		{
			GtkLabel* _tmp6_;
			GSimpleAction* _tmp7_;
			GVariant* _tmp8_;
			GVariant* _tmp9_;
			_tmp6_ = self->priv->mode_label;
			gtk_label_set_label (_tmp6_, _ ("Basic Mode"));
			_tmp7_ = action;
			_tmp8_ = g_variant_new_string ("basic");
			g_variant_ref_sink (_tmp8_);
			_tmp9_ = _tmp8_;
			g_simple_action_set_state (_tmp7_, _tmp9_);
			_g_variant_unref0 (_tmp9_);
			break;
		}
		case BUTTON_MODE_ADVANCED:
		{
			GtkLabel* _tmp10_;
			GSimpleAction* _tmp11_;
			GVariant* _tmp12_;
			GVariant* _tmp13_;
			_tmp10_ = self->priv->mode_label;
			gtk_label_set_label (_tmp10_, _ ("Advanced Mode"));
			_tmp11_ = action;
			_tmp12_ = g_variant_new_string ("advanced");
			g_variant_ref_sink (_tmp12_);
			_tmp13_ = _tmp12_;
			g_simple_action_set_state (_tmp11_, _tmp13_);
			_g_variant_unref0 (_tmp13_);
			break;
		}
		case BUTTON_MODE_FINANCIAL:
		{
			GtkLabel* _tmp14_;
			GSimpleAction* _tmp15_;
			GVariant* _tmp16_;
			GVariant* _tmp17_;
			_tmp14_ = self->priv->mode_label;
			gtk_label_set_label (_tmp14_, _ ("Financial Mode"));
			_tmp15_ = action;
			_tmp16_ = g_variant_new_string ("financial");
			g_variant_ref_sink (_tmp16_);
			_tmp17_ = _tmp16_;
			g_simple_action_set_state (_tmp15_, _tmp17_);
			_g_variant_unref0 (_tmp17_);
			break;
		}
		case BUTTON_MODE_PROGRAMMING:
		{
			GtkLabel* _tmp18_;
			GSimpleAction* _tmp19_;
			GVariant* _tmp20_;
			GVariant* _tmp21_;
			_tmp18_ = self->priv->mode_label;
			gtk_label_set_label (_tmp18_, _ ("Programming Mode"));
			_tmp19_ = action;
			_tmp20_ = g_variant_new_string ("programming");
			g_variant_ref_sink (_tmp20_);
			_tmp21_ = _tmp20_;
			g_simple_action_set_state (_tmp19_, _tmp21_);
			_g_variant_unref0 (_tmp21_);
			break;
		}
		case BUTTON_MODE_KEYBOARD:
		{
			GtkLabel* _tmp22_;
			GSimpleAction* _tmp23_;
			GVariant* _tmp24_;
			GVariant* _tmp25_;
			_tmp22_ = self->priv->mode_label;
			gtk_label_set_label (_tmp22_, _ ("Keyboard Mode"));
			_tmp23_ = action;
			_tmp24_ = g_variant_new_string ("keyboard");
			g_variant_ref_sink (_tmp24_);
			_tmp25_ = _tmp24_;
			g_simple_action_set_state (_tmp23_, _tmp25_);
			_g_variant_unref0 (_tmp25_);
			break;
		}
	}
	_tmp27_ = self->priv->remove_buttons;
	if (_tmp27_ == TRUE) {
		MathButtons* _tmp28_;
		ButtonMode _tmp29_;
		ButtonMode _tmp30_;
		_tmp28_ = self->priv->_buttons;
		_tmp29_ = math_buttons_get_mode (_tmp28_);
		_tmp30_ = _tmp29_;
		_tmp26_ = _tmp30_ != BUTTON_MODE_KEYBOARD;
	} else {
		_tmp26_ = FALSE;
	}
	if (_tmp26_) {
		MathButtons* _tmp31_;
		MathConverter* _tmp32_;
		_tmp31_ = self->priv->_buttons;
		gtk_widget_show ((GtkWidget*) _tmp31_);
		self->priv->remove_buttons = FALSE;
		_tmp32_ = self->priv->converter;
		gtk_widget_hide ((GtkWidget*) _tmp32_);
	} else {
		gboolean _tmp33_ = FALSE;
		gboolean _tmp34_;
		_tmp34_ = self->priv->remove_buttons;
		if (_tmp34_ == FALSE) {
			MathButtons* _tmp35_;
			ButtonMode _tmp36_;
			ButtonMode _tmp37_;
			_tmp35_ = self->priv->_buttons;
			_tmp36_ = math_buttons_get_mode (_tmp35_);
			_tmp37_ = _tmp36_;
			_tmp33_ = _tmp37_ == BUTTON_MODE_KEYBOARD;
		} else {
			_tmp33_ = FALSE;
		}
		if (_tmp33_) {
			MathButtons* _tmp38_;
			MathConverter* _tmp39_;
			_tmp38_ = self->priv->_buttons;
			gtk_widget_hide ((GtkWidget*) _tmp38_);
			self->priv->remove_buttons = TRUE;
			_tmp39_ = self->priv->converter;
			gtk_widget_show ((GtkWidget*) _tmp39_);
		}
	}
	_g_object_unref0 (action);
}


void
math_window_critical_error (MathWindow* self,
                            const gchar* title,
                            const gchar* contents)
{
	GtkMessageDialog* dialog = NULL;
	GtkMessageDialog* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (title != NULL);
	g_return_if_fail (contents != NULL);
	_tmp0_ = (GtkMessageDialog*) gtk_message_dialog_new (NULL, 0, GTK_MESSAGE_ERROR, GTK_BUTTONS_NONE, "%s", title);
	g_object_ref_sink (_tmp0_);
	dialog = _tmp0_;
	gtk_message_dialog_format_secondary_text (dialog, "%s", contents);
	gtk_dialog_add_buttons ((GtkDialog*) dialog, _ ("_Quit"), GTK_RESPONSE_ACCEPT, NULL);
	gtk_dialog_run ((GtkDialog*) dialog);
	gtk_widget_destroy ((GtkWidget*) self);
	_g_object_unref0 (dialog);
}


static gboolean
math_window_real_key_press_event (GtkWidget* base,
                                  GdkEventKey* event)
{
	MathWindow * self;
	gboolean result = FALSE;
	gboolean _result_ = FALSE;
	gboolean _tmp0_ = FALSE;
	MathButtons* _tmp1_;
	MathButtons* _tmp2_;
	ButtonMode _tmp3_;
	ButtonMode _tmp4_;
	self = (MathWindow*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	_result_ = GTK_WIDGET_CLASS (math_window_parent_class)->key_press_event ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_application_window_get_type (), GtkApplicationWindow), event);
	_tmp1_ = math_window_get_buttons (self);
	_tmp2_ = _tmp1_;
	_tmp3_ = math_buttons_get_mode (_tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_ == BUTTON_MODE_PROGRAMMING) {
		GdkModifierType _tmp5_;
		_tmp5_ = event->state;
		_tmp0_ = (_tmp5_ & GDK_CONTROL_MASK) == GDK_CONTROL_MASK;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		guint _tmp6_;
		_tmp6_ = event->keyval;
		switch (_tmp6_) {
			case GDK_KEY_b:
			{
				MathEquation* _tmp7_;
				MathEquation* _tmp8_;
				_tmp7_ = math_window_get_equation (self);
				_tmp8_ = _tmp7_;
				math_equation_set_number_base (_tmp8_, 2);
				result = TRUE;
				return result;
			}
			case GDK_KEY_o:
			{
				MathEquation* _tmp9_;
				MathEquation* _tmp10_;
				_tmp9_ = math_window_get_equation (self);
				_tmp10_ = _tmp9_;
				math_equation_set_number_base (_tmp10_, 8);
				result = TRUE;
				return result;
			}
			case GDK_KEY_d:
			{
				MathEquation* _tmp11_;
				MathEquation* _tmp12_;
				_tmp11_ = math_window_get_equation (self);
				_tmp12_ = _tmp11_;
				math_equation_set_number_base (_tmp12_, 10);
				result = TRUE;
				return result;
			}
			case GDK_KEY_h:
			{
				MathEquation* _tmp13_;
				MathEquation* _tmp14_;
				_tmp13_ = math_window_get_equation (self);
				_tmp14_ = _tmp13_;
				math_equation_set_number_base (_tmp14_, 16);
				result = TRUE;
				return result;
			}
			default:
			break;
		}
	}
	result = _result_;
	return result;
}


static void
math_window_scroll_changed_cb (MathWindow* self,
                               GtkAdjustment* adjustment)
{
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (adjustment != NULL);
	_tmp0_ = self->priv->right_aligned;
	if (_tmp0_) {
		gtk_adjustment_set_value (adjustment, gtk_adjustment_get_upper (adjustment) - gtk_adjustment_get_page_size (adjustment));
	}
}


static void
_math_window_scroll_changed_cb_gtk_adjustment_changed (GtkAdjustment* _sender,
                                                       gpointer self)
{
	math_window_scroll_changed_cb ((MathWindow*) self, _sender);
}


static void
math_window_scroll_value_changed_cb (MathWindow* self,
                                     GtkAdjustment* adjustment)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (adjustment != NULL);
	if (gtk_adjustment_get_value (adjustment) == (gtk_adjustment_get_upper (adjustment) - gtk_adjustment_get_page_size (adjustment))) {
		self->priv->right_aligned = TRUE;
	} else {
		self->priv->right_aligned = FALSE;
	}
}


static void
_math_window_scroll_value_changed_cb_gtk_adjustment_value_changed (GtkAdjustment* _sender,
                                                                   gpointer self)
{
	math_window_scroll_value_changed_cb ((MathWindow*) self, _sender);
}


static void
math_window_copy_cb (MathWindow* self)
{
	MathEquation* _tmp0_;
	MathEquation* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = math_window_get_equation (self);
	_tmp1_ = _tmp0_;
	math_equation_copy (_tmp1_);
}


static void
math_window_paste_cb (MathWindow* self)
{
	MathEquation* _tmp0_;
	MathEquation* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = math_window_get_equation (self);
	_tmp1_ = _tmp0_;
	math_equation_paste (_tmp1_);
}


static void
math_window_undo_cb (MathWindow* self)
{
	MathEquation* _tmp0_;
	MathEquation* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = math_window_get_equation (self);
	_tmp1_ = _tmp0_;
	gtk_source_buffer_undo ((GtkSourceBuffer*) _tmp1_);
}


static void
math_window_redo_cb (MathWindow* self)
{
	MathEquation* _tmp0_;
	MathEquation* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = math_window_get_equation (self);
	_tmp1_ = _tmp0_;
	gtk_source_buffer_redo ((GtkSourceBuffer*) _tmp1_);
}


static void
math_window_mode_cb (MathWindow* self,
                     GSimpleAction* action,
                     GVariant* parameter)
{
	const GVariantType* _tmp0_;
	GtkPopover* popover = NULL;
	GtkMenuButton* _tmp1_;
	GtkPopover* _tmp2_;
	GtkPopover* _tmp3_;
	GtkPopover* _tmp4_;
	GtkMenuButton* _tmp5_;
	MathDisplay* _tmp6_;
	MathDisplay* _tmp7_;
	ButtonMode mode = 0;
	gchar* mode_str = NULL;
	const gchar* _tmp8_;
	gchar* _tmp9_;
	const gchar* _tmp10_;
	MathButtons* _tmp15_;
	MathButtons* _tmp16_;
	ButtonMode _tmp17_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_vala_return_if_fail (parameter != NULL, "parameter != null");
	_tmp0_ = G_VARIANT_TYPE_STRING;
	_vala_return_if_fail (g_variant_is_of_type (parameter, _tmp0_), "parameter.is_of_type (VariantType.STRING)");
	_tmp1_ = self->priv->menu_button;
	_tmp2_ = gtk_menu_button_get_popover (_tmp1_);
	_tmp3_ = _g_object_ref0 (_tmp2_);
	popover = _tmp3_;
	_tmp4_ = popover;
	gtk_widget_hide ((GtkWidget*) _tmp4_);
	_tmp5_ = self->priv->menu_button;
	gtk_toggle_button_set_active ((GtkToggleButton*) _tmp5_, FALSE);
	_tmp6_ = math_window_get_display (self);
	_tmp7_ = _tmp6_;
	math_display_grab_focus (_tmp7_);
	mode = BUTTON_MODE_BASIC;
	_tmp8_ = g_variant_get_string (parameter, NULL);
	_tmp9_ = g_strdup (_tmp8_);
	mode_str = _tmp9_;
	_tmp10_ = mode_str;
	if (g_strcmp0 (_tmp10_, "basic") == 0) {
		mode = BUTTON_MODE_BASIC;
	} else {
		const gchar* _tmp11_;
		_tmp11_ = mode_str;
		if (g_strcmp0 (_tmp11_, "advanced") == 0) {
			mode = BUTTON_MODE_ADVANCED;
		} else {
			const gchar* _tmp12_;
			_tmp12_ = mode_str;
			if (g_strcmp0 (_tmp12_, "financial") == 0) {
				mode = BUTTON_MODE_FINANCIAL;
			} else {
				const gchar* _tmp13_;
				_tmp13_ = mode_str;
				if (g_strcmp0 (_tmp13_, "programming") == 0) {
					mode = BUTTON_MODE_PROGRAMMING;
				} else {
					const gchar* _tmp14_;
					_tmp14_ = mode_str;
					if (g_strcmp0 (_tmp14_, "keyboard") == 0) {
						mode = BUTTON_MODE_KEYBOARD;
					} else {
						g_assert_not_reached ();
					}
				}
			}
		}
	}
	_tmp15_ = math_window_get_buttons (self);
	_tmp16_ = _tmp15_;
	_tmp17_ = mode;
	math_buttons_set_mode (_tmp16_, _tmp17_);
	_g_free0 (mode_str);
	_g_object_unref0 (popover);
}


MathEquation*
math_window_get_equation (MathWindow* self)
{
	MathEquation* result;
	MathEquation* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_equation;
	result = _tmp0_;
	return result;
}


MathDisplay*
math_window_get_display (MathWindow* self)
{
	MathDisplay* result;
	MathDisplay* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_display;
	result = _tmp0_;
	return result;
}


MathButtons*
math_window_get_buttons (MathWindow* self)
{
	MathButtons* result;
	MathButtons* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_buttons;
	result = _tmp0_;
	return result;
}


static void
math_window_class_init (MathWindowClass * klass)
{
	gint MathWindow_private_offset;
	math_window_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (MathWindowPrivate));
	((GtkWidgetClass *) klass)->key_press_event = (gboolean (*) (GtkWidget *, GdkEventKey*)) math_window_real_key_press_event;
	G_OBJECT_CLASS (klass)->get_property = _vala_math_window_get_property;
	G_OBJECT_CLASS (klass)->finalize = math_window_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), MATH_WINDOW_EQUATION_PROPERTY, math_window_properties[MATH_WINDOW_EQUATION_PROPERTY] = g_param_spec_object ("equation", "equation", "equation", TYPE_MATH_EQUATION, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MATH_WINDOW_DISPLAY_PROPERTY, math_window_properties[MATH_WINDOW_DISPLAY_PROPERTY] = g_param_spec_object ("display", "display", "display", TYPE_MATH_DISPLAY, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MATH_WINDOW_BUTTONS_PROPERTY, math_window_properties[MATH_WINDOW_BUTTONS_PROPERTY] = g_param_spec_object ("buttons", "buttons", "buttons", TYPE_MATH_BUTTONS, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	MathWindow_private_offset = g_type_class_get_instance_private_offset (klass);
	gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass), "/org/gnome/calculator/math-window.ui");
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "menu_button", FALSE, MathWindow_private_offset + G_STRUCT_OFFSET (MathWindowPrivate, menu_button));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "mode_label", FALSE, MathWindow_private_offset + G_STRUCT_OFFSET (MathWindowPrivate, mode_label));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "grid", FALSE, MathWindow_private_offset + G_STRUCT_OFFSET (MathWindowPrivate, grid));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "converter", FALSE, MathWindow_private_offset + G_STRUCT_OFFSET (MathWindowPrivate, converter));
	gtk_widget_class_bind_template_callback_full (GTK_WIDGET_CLASS (klass), "scroll_changed_cb", G_CALLBACK(_math_window_scroll_changed_cb_gtk_adjustment_changed));
	gtk_widget_class_bind_template_callback_full (GTK_WIDGET_CLASS (klass), "scroll_value_changed_cb", G_CALLBACK(_math_window_scroll_value_changed_cb_gtk_adjustment_value_changed));
}


static void
math_window_instance_init (MathWindow * self)
{
	self->priv = MATH_WINDOW_GET_PRIVATE (self);
	g_type_ensure (TYPE_MATH_CONVERTER);
	gtk_widget_init_template (GTK_WIDGET (self));
}


static void
math_window_finalize (GObject * obj)
{
	MathWindow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_MATH_WINDOW, MathWindow);
	_g_object_unref0 (self->priv->_equation);
	_g_object_unref0 (self->priv->_display);
	_g_object_unref0 (self->priv->_buttons);
	_g_object_unref0 (self->priv->menu_button);
	_g_object_unref0 (self->priv->mode_label);
	_g_object_unref0 (self->priv->grid);
	_g_object_unref0 (self->priv->converter);
	G_OBJECT_CLASS (math_window_parent_class)->finalize (obj);
}


GType
math_window_get_type (void)
{
	static volatile gsize math_window_type_id__volatile = 0;
	if (g_once_init_enter (&math_window_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MathWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) math_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MathWindow), 0, (GInstanceInitFunc) math_window_instance_init, NULL };
		GType math_window_type_id;
		math_window_type_id = g_type_register_static (gtk_application_window_get_type (), "MathWindow", &g_define_type_info, 0);
		g_once_init_leave (&math_window_type_id__volatile, math_window_type_id);
	}
	return math_window_type_id__volatile;
}


static void
_vala_math_window_get_property (GObject * object,
                                guint property_id,
                                GValue * value,
                                GParamSpec * pspec)
{
	MathWindow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_MATH_WINDOW, MathWindow);
	switch (property_id) {
		case MATH_WINDOW_EQUATION_PROPERTY:
		g_value_set_object (value, math_window_get_equation (self));
		break;
		case MATH_WINDOW_DISPLAY_PROPERTY:
		g_value_set_object (value, math_window_get_display (self));
		break;
		case MATH_WINDOW_BUTTONS_PROPERTY:
		g_value_set_object (value, math_window_get_buttons (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



